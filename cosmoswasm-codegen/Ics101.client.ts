/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { ExecuteMsg, Uint128, PoolSide, SwapMsgType, MsgMakePoolRequest, PoolAsset, Coin, MsgTakePoolRequest, MsgCancelPoolRequest, MsgSingleAssetDepositRequest, MsgMakeMultiAssetDepositRequest, DepositAsset, MsgCancelMultiAssetDepositRequest, MsgTakeMultiAssetDepositRequest, MsgMultiAssetWithdrawRequest, MsgSwapRequest, InstantiateMsg, QueryMsg } from "./Ics101.types";
export interface Ics101ReadOnlyInterface {
  contractAddress: string;
  orderList: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<OrderListResponse>;
  order: ({
    orderId,
    poolId
  }: {
    orderId: string;
    poolId: string;
  }) => Promise<OrderResponse>;
  config: () => Promise<ConfigResponse>;
  poolTokenList: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PoolTokenListResponse>;
  poolAddressByToken: ({
    poolId
  }: {
    poolId: string;
  }) => Promise<PoolAddressByTokenResponse>;
  interchainPool: ({
    poolId
  }: {
    poolId: string;
  }) => Promise<InterchainPoolResponse>;
  interchainPoolList: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<InterchainPoolListResponse>;
  leftSwap: ({
    poolId,
    tokenIn,
    tokenOut
  }: {
    poolId: string;
    tokenIn: Coin;
    tokenOut: Coin;
  }) => Promise<LeftSwapResponse>;
  rightSwap: ({
    poolId,
    tokenIn,
    tokenOut
  }: {
    poolId: string;
    tokenIn: Coin;
    tokenOut: Coin;
  }) => Promise<RightSwapResponse>;
  queryActiveOrders: ({
    destinationTaker,
    poolId,
    sourceMaker
  }: {
    destinationTaker: string;
    poolId: string;
    sourceMaker: string;
  }) => Promise<QueryActiveOrdersResponse>;
  rate: ({
    amount,
    poolId
  }: {
    amount: Uint128;
    poolId: string;
  }) => Promise<RateResponse>;
}
export class Ics101QueryClient implements Ics101ReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.orderList = this.orderList.bind(this);
    this.order = this.order.bind(this);
    this.config = this.config.bind(this);
    this.poolTokenList = this.poolTokenList.bind(this);
    this.poolAddressByToken = this.poolAddressByToken.bind(this);
    this.interchainPool = this.interchainPool.bind(this);
    this.interchainPoolList = this.interchainPoolList.bind(this);
    this.leftSwap = this.leftSwap.bind(this);
    this.rightSwap = this.rightSwap.bind(this);
    this.queryActiveOrders = this.queryActiveOrders.bind(this);
    this.rate = this.rate.bind(this);
  }

  orderList = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<OrderListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      OrderList: {
        limit,
        start_after: startAfter
      }
    });
  };
  order = async ({
    orderId,
    poolId
  }: {
    orderId: string;
    poolId: string;
  }): Promise<OrderResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      Order: {
        order_id: orderId,
        pool_id: poolId
      }
    });
  };
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      Config: {}
    });
  };
  poolTokenList = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PoolTokenListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      PoolTokenList: {
        limit,
        start_after: startAfter
      }
    });
  };
  poolAddressByToken = async ({
    poolId
  }: {
    poolId: string;
  }): Promise<PoolAddressByTokenResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      PoolAddressByToken: {
        pool_id: poolId
      }
    });
  };
  interchainPool = async ({
    poolId
  }: {
    poolId: string;
  }): Promise<InterchainPoolResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      InterchainPool: {
        pool_id: poolId
      }
    });
  };
  interchainPoolList = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<InterchainPoolListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      InterchainPoolList: {
        limit,
        start_after: startAfter
      }
    });
  };
  leftSwap = async ({
    poolId,
    tokenIn,
    tokenOut
  }: {
    poolId: string;
    tokenIn: Coin;
    tokenOut: Coin;
  }): Promise<LeftSwapResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      LeftSwap: {
        pool_id: poolId,
        token_in: tokenIn,
        token_out: tokenOut
      }
    });
  };
  rightSwap = async ({
    poolId,
    tokenIn,
    tokenOut
  }: {
    poolId: string;
    tokenIn: Coin;
    tokenOut: Coin;
  }): Promise<RightSwapResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      RightSwap: {
        pool_id: poolId,
        token_in: tokenIn,
        token_out: tokenOut
      }
    });
  };
  queryActiveOrders = async ({
    destinationTaker,
    poolId,
    sourceMaker
  }: {
    destinationTaker: string;
    poolId: string;
    sourceMaker: string;
  }): Promise<QueryActiveOrdersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      QueryActiveOrders: {
        destination_taker: destinationTaker,
        pool_id: poolId,
        source_maker: sourceMaker
      }
    });
  };
  rate = async ({
    amount,
    poolId
  }: {
    amount: Uint128;
    poolId: string;
  }): Promise<RateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      Rate: {
        amount,
        pool_id: poolId
      }
    });
  };
}
export interface Ics101Interface extends Ics101ReadOnlyInterface {
  contractAddress: string;
  sender: string;
  makePool: ({
    counterpartyChannel,
    counterpartyCreator,
    creator,
    destinationChainId,
    liquidity,
    sourceChainId,
    sourceChannel,
    sourcePort,
    swapFee,
    timeoutHeight,
    timeoutTimestamp
  }: {
    counterpartyChannel: string;
    counterpartyCreator: string;
    creator: string;
    destinationChainId: string;
    liquidity: PoolAsset[];
    sourceChainId: string;
    sourceChannel: string;
    sourcePort: string;
    swapFee: number;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  takePool: ({
    counterCreator,
    creator,
    poolId,
    timeoutHeight,
    timeoutTimestamp
  }: {
    counterCreator: string;
    creator: string;
    poolId: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  cancelPool: ({
    poolId,
    timeoutHeight,
    timeoutTimestamp
  }: {
    poolId: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  singleAssetDeposit: ({
    poolId,
    sender,
    timeoutHeight,
    timeoutTimestamp,
    token
  }: {
    poolId: string;
    sender: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
    token: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  makeMultiAssetDeposit: ({
    chainId,
    deposits,
    poolId,
    timeoutHeight,
    timeoutTimestamp
  }: {
    chainId: string;
    deposits: DepositAsset[];
    poolId: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  cancelMultiAssetDeposit: ({
    orderId,
    poolId,
    sender,
    timeoutHeight,
    timeoutTimestamp
  }: {
    orderId: string;
    poolId: string;
    sender: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  takeMultiAssetDeposit: ({
    orderId,
    poolId,
    sender,
    timeoutHeight,
    timeoutTimestamp
  }: {
    orderId: string;
    poolId: string;
    sender: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  multiAssetWithdraw: ({
    counterpartyReceiver,
    poolId,
    poolToken,
    receiver,
    timeoutHeight,
    timeoutTimestamp
  }: {
    counterpartyReceiver: string;
    poolId: string;
    poolToken: Coin;
    receiver: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  swap: ({
    poolId,
    recipient,
    sender,
    slippage,
    swapType,
    timeoutHeight,
    timeoutTimestamp,
    tokenIn,
    tokenOut
  }: {
    poolId: string;
    recipient: string;
    sender: string;
    slippage: number;
    swapType: SwapMsgType;
    timeoutHeight: number;
    timeoutTimestamp: number;
    tokenIn: Coin;
    tokenOut: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class Ics101Client extends Ics101QueryClient implements Ics101Interface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.makePool = this.makePool.bind(this);
    this.takePool = this.takePool.bind(this);
    this.cancelPool = this.cancelPool.bind(this);
    this.singleAssetDeposit = this.singleAssetDeposit.bind(this);
    this.makeMultiAssetDeposit = this.makeMultiAssetDeposit.bind(this);
    this.cancelMultiAssetDeposit = this.cancelMultiAssetDeposit.bind(this);
    this.takeMultiAssetDeposit = this.takeMultiAssetDeposit.bind(this);
    this.multiAssetWithdraw = this.multiAssetWithdraw.bind(this);
    this.swap = this.swap.bind(this);
  }

  makePool = async ({
    counterpartyChannel,
    counterpartyCreator,
    creator,
    destinationChainId,
    liquidity,
    sourceChainId,
    sourceChannel,
    sourcePort,
    swapFee,
    timeoutHeight,
    timeoutTimestamp
  }: {
    counterpartyChannel: string;
    counterpartyCreator: string;
    creator: string;
    destinationChainId: string;
    liquidity: PoolAsset[];
    sourceChainId: string;
    sourceChannel: string;
    sourcePort: string;
    swapFee: number;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      MakePool: {
        counterpartyChannel,
        counterpartyCreator,
        creator,
        destinationChainId,
        liquidity,
        sourceChainId,
        sourceChannel,
        sourcePort,
        swapFee,
        timeoutHeight,
        timeoutTimestamp
      }
    }, fee, memo, _funds);
  };
  takePool = async ({
    counterCreator,
    creator,
    poolId,
    timeoutHeight,
    timeoutTimestamp
  }: {
    counterCreator: string;
    creator: string;
    poolId: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      TakePool: {
        counterCreator,
        creator,
        poolId,
        timeoutHeight,
        timeoutTimestamp
      }
    }, fee, memo, _funds);
  };
  cancelPool = async ({
    poolId,
    timeoutHeight,
    timeoutTimestamp
  }: {
    poolId: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      CancelPool: {
        poolId,
        timeoutHeight,
        timeoutTimestamp
      }
    }, fee, memo, _funds);
  };
  singleAssetDeposit = async ({
    poolId,
    sender,
    timeoutHeight,
    timeoutTimestamp,
    token
  }: {
    poolId: string;
    sender: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
    token: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      SingleAssetDeposit: {
        poolId,
        sender,
        timeoutHeight,
        timeoutTimestamp,
        token
      }
    }, fee, memo, _funds);
  };
  makeMultiAssetDeposit = async ({
    chainId,
    deposits,
    poolId,
    timeoutHeight,
    timeoutTimestamp
  }: {
    chainId: string;
    deposits: DepositAsset[];
    poolId: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      MakeMultiAssetDeposit: {
        chainId,
        deposits,
        poolId,
        timeoutHeight,
        timeoutTimestamp
      }
    }, fee, memo, _funds);
  };
  cancelMultiAssetDeposit = async ({
    orderId,
    poolId,
    sender,
    timeoutHeight,
    timeoutTimestamp
  }: {
    orderId: string;
    poolId: string;
    sender: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      CancelMultiAssetDeposit: {
        orderId,
        poolId,
        sender,
        timeoutHeight,
        timeoutTimestamp
      }
    }, fee, memo, _funds);
  };
  takeMultiAssetDeposit = async ({
    orderId,
    poolId,
    sender,
    timeoutHeight,
    timeoutTimestamp
  }: {
    orderId: string;
    poolId: string;
    sender: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      TakeMultiAssetDeposit: {
        orderId,
        poolId,
        sender,
        timeoutHeight,
        timeoutTimestamp
      }
    }, fee, memo, _funds);
  };
  multiAssetWithdraw = async ({
    counterpartyReceiver,
    poolId,
    poolToken,
    receiver,
    timeoutHeight,
    timeoutTimestamp
  }: {
    counterpartyReceiver: string;
    poolId: string;
    poolToken: Coin;
    receiver: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      MultiAssetWithdraw: {
        counterpartyReceiver,
        poolId,
        poolToken,
        receiver,
        timeoutHeight,
        timeoutTimestamp
      }
    }, fee, memo, _funds);
  };
  swap = async ({
    poolId,
    recipient,
    sender,
    slippage,
    swapType,
    timeoutHeight,
    timeoutTimestamp,
    tokenIn,
    tokenOut
  }: {
    poolId: string;
    recipient: string;
    sender: string;
    slippage: number;
    swapType: SwapMsgType;
    timeoutHeight: number;
    timeoutTimestamp: number;
    tokenIn: Coin;
    tokenOut: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      Swap: {
        poolId,
        recipient,
        sender,
        slippage,
        swapType,
        timeoutHeight,
        timeoutTimestamp,
        tokenIn,
        tokenOut
      }
    }, fee, memo, _funds);
  };
}