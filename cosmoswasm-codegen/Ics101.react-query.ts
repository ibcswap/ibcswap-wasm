/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { ExecuteMsg, Uint128, PoolSide, SwapMsgType, MsgMakePoolRequest, PoolAsset, Coin, MsgTakePoolRequest, MsgCancelPoolRequest, MsgSingleAssetDepositRequest, MsgMakeMultiAssetDepositRequest, DepositAsset, MsgCancelMultiAssetDepositRequest, MsgTakeMultiAssetDepositRequest, MsgMultiAssetWithdrawRequest, MsgSwapRequest, InstantiateMsg, QueryMsg } from "./Ics101.types";
import { Ics101QueryClient, Ics101Client } from "./Ics101.client";
export const ics101QueryKeys = {
  contract: ([{
    contract: "ics101"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...ics101QueryKeys.contract[0],
    address: contractAddress
  }] as const),
  orderList: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "OrderList",
    args
  }] as const),
  order: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "Order",
    args
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "Config",
    args
  }] as const),
  poolTokenList: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "PoolTokenList",
    args
  }] as const),
  poolAddressByToken: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "PoolAddressByToken",
    args
  }] as const),
  interchainPool: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "InterchainPool",
    args
  }] as const),
  interchainPoolList: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "InterchainPoolList",
    args
  }] as const),
  leftSwap: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "LeftSwap",
    args
  }] as const),
  rightSwap: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "RightSwap",
    args
  }] as const),
  queryActiveOrders: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "QueryActiveOrders",
    args
  }] as const),
  rate: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...ics101QueryKeys.address(contractAddress)[0],
    method: "Rate",
    args
  }] as const)
};
export const ics101Queries = {
  orderList: <TData = OrderListResponse,>({
    client,
    args,
    options
  }: Ics101OrderListQuery<TData>): UseQueryOptions<OrderListResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.orderList(client?.contractAddress, args),
    queryFn: () => client ? client.orderList({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  order: <TData = OrderResponse,>({
    client,
    args,
    options
  }: Ics101OrderQuery<TData>): UseQueryOptions<OrderResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.order(client?.contractAddress, args),
    queryFn: () => client ? client.order({
      orderId: args.orderId,
      poolId: args.poolId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  config: <TData = ConfigResponse,>({
    client,
    options
  }: Ics101ConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  poolTokenList: <TData = PoolTokenListResponse,>({
    client,
    args,
    options
  }: Ics101PoolTokenListQuery<TData>): UseQueryOptions<PoolTokenListResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.poolTokenList(client?.contractAddress, args),
    queryFn: () => client ? client.poolTokenList({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  poolAddressByToken: <TData = PoolAddressByTokenResponse,>({
    client,
    args,
    options
  }: Ics101PoolAddressByTokenQuery<TData>): UseQueryOptions<PoolAddressByTokenResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.poolAddressByToken(client?.contractAddress, args),
    queryFn: () => client ? client.poolAddressByToken({
      poolId: args.poolId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  interchainPool: <TData = InterchainPoolResponse,>({
    client,
    args,
    options
  }: Ics101InterchainPoolQuery<TData>): UseQueryOptions<InterchainPoolResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.interchainPool(client?.contractAddress, args),
    queryFn: () => client ? client.interchainPool({
      poolId: args.poolId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  interchainPoolList: <TData = InterchainPoolListResponse,>({
    client,
    args,
    options
  }: Ics101InterchainPoolListQuery<TData>): UseQueryOptions<InterchainPoolListResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.interchainPoolList(client?.contractAddress, args),
    queryFn: () => client ? client.interchainPoolList({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  leftSwap: <TData = LeftSwapResponse,>({
    client,
    args,
    options
  }: Ics101LeftSwapQuery<TData>): UseQueryOptions<LeftSwapResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.leftSwap(client?.contractAddress, args),
    queryFn: () => client ? client.leftSwap({
      poolId: args.poolId,
      tokenIn: args.tokenIn,
      tokenOut: args.tokenOut
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  rightSwap: <TData = RightSwapResponse,>({
    client,
    args,
    options
  }: Ics101RightSwapQuery<TData>): UseQueryOptions<RightSwapResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.rightSwap(client?.contractAddress, args),
    queryFn: () => client ? client.rightSwap({
      poolId: args.poolId,
      tokenIn: args.tokenIn,
      tokenOut: args.tokenOut
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  queryActiveOrders: <TData = QueryActiveOrdersResponse,>({
    client,
    args,
    options
  }: Ics101QueryActiveOrdersQuery<TData>): UseQueryOptions<QueryActiveOrdersResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.queryActiveOrders(client?.contractAddress, args),
    queryFn: () => client ? client.queryActiveOrders({
      destinationTaker: args.destinationTaker,
      poolId: args.poolId,
      sourceMaker: args.sourceMaker
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  rate: <TData = RateResponse,>({
    client,
    args,
    options
  }: Ics101RateQuery<TData>): UseQueryOptions<RateResponse, Error, TData> => ({
    queryKey: ics101QueryKeys.rate(client?.contractAddress, args),
    queryFn: () => client ? client.rate({
      amount: args.amount,
      poolId: args.poolId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface Ics101ReactQuery<TResponse, TData = TResponse> {
  client: Ics101QueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface Ics101RateQuery<TData> extends Ics101ReactQuery<RateResponse, TData> {
  args: {
    amount: Uint128;
    poolId: string;
  };
}
export function useIcs101RateQuery<TData = RateResponse>({
  client,
  args,
  options
}: Ics101RateQuery<TData>) {
  return useQuery<RateResponse, Error, TData>(ics101QueryKeys.rate(client?.contractAddress, args), () => client ? client.rate({
    amount: args.amount,
    poolId: args.poolId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101QueryActiveOrdersQuery<TData> extends Ics101ReactQuery<QueryActiveOrdersResponse, TData> {
  args: {
    destinationTaker: string;
    poolId: string;
    sourceMaker: string;
  };
}
export function useIcs101QueryActiveOrdersQuery<TData = QueryActiveOrdersResponse>({
  client,
  args,
  options
}: Ics101QueryActiveOrdersQuery<TData>) {
  return useQuery<QueryActiveOrdersResponse, Error, TData>(ics101QueryKeys.queryActiveOrders(client?.contractAddress, args), () => client ? client.queryActiveOrders({
    destinationTaker: args.destinationTaker,
    poolId: args.poolId,
    sourceMaker: args.sourceMaker
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101RightSwapQuery<TData> extends Ics101ReactQuery<RightSwapResponse, TData> {
  args: {
    poolId: string;
    tokenIn: Coin;
    tokenOut: Coin;
  };
}
export function useIcs101RightSwapQuery<TData = RightSwapResponse>({
  client,
  args,
  options
}: Ics101RightSwapQuery<TData>) {
  return useQuery<RightSwapResponse, Error, TData>(ics101QueryKeys.rightSwap(client?.contractAddress, args), () => client ? client.rightSwap({
    poolId: args.poolId,
    tokenIn: args.tokenIn,
    tokenOut: args.tokenOut
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101LeftSwapQuery<TData> extends Ics101ReactQuery<LeftSwapResponse, TData> {
  args: {
    poolId: string;
    tokenIn: Coin;
    tokenOut: Coin;
  };
}
export function useIcs101LeftSwapQuery<TData = LeftSwapResponse>({
  client,
  args,
  options
}: Ics101LeftSwapQuery<TData>) {
  return useQuery<LeftSwapResponse, Error, TData>(ics101QueryKeys.leftSwap(client?.contractAddress, args), () => client ? client.leftSwap({
    poolId: args.poolId,
    tokenIn: args.tokenIn,
    tokenOut: args.tokenOut
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101InterchainPoolListQuery<TData> extends Ics101ReactQuery<InterchainPoolListResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useIcs101InterchainPoolListQuery<TData = InterchainPoolListResponse>({
  client,
  args,
  options
}: Ics101InterchainPoolListQuery<TData>) {
  return useQuery<InterchainPoolListResponse, Error, TData>(ics101QueryKeys.interchainPoolList(client?.contractAddress, args), () => client ? client.interchainPoolList({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101InterchainPoolQuery<TData> extends Ics101ReactQuery<InterchainPoolResponse, TData> {
  args: {
    poolId: string;
  };
}
export function useIcs101InterchainPoolQuery<TData = InterchainPoolResponse>({
  client,
  args,
  options
}: Ics101InterchainPoolQuery<TData>) {
  return useQuery<InterchainPoolResponse, Error, TData>(ics101QueryKeys.interchainPool(client?.contractAddress, args), () => client ? client.interchainPool({
    poolId: args.poolId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101PoolAddressByTokenQuery<TData> extends Ics101ReactQuery<PoolAddressByTokenResponse, TData> {
  args: {
    poolId: string;
  };
}
export function useIcs101PoolAddressByTokenQuery<TData = PoolAddressByTokenResponse>({
  client,
  args,
  options
}: Ics101PoolAddressByTokenQuery<TData>) {
  return useQuery<PoolAddressByTokenResponse, Error, TData>(ics101QueryKeys.poolAddressByToken(client?.contractAddress, args), () => client ? client.poolAddressByToken({
    poolId: args.poolId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101PoolTokenListQuery<TData> extends Ics101ReactQuery<PoolTokenListResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useIcs101PoolTokenListQuery<TData = PoolTokenListResponse>({
  client,
  args,
  options
}: Ics101PoolTokenListQuery<TData>) {
  return useQuery<PoolTokenListResponse, Error, TData>(ics101QueryKeys.poolTokenList(client?.contractAddress, args), () => client ? client.poolTokenList({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101ConfigQuery<TData> extends Ics101ReactQuery<ConfigResponse, TData> {}
export function useIcs101ConfigQuery<TData = ConfigResponse>({
  client,
  options
}: Ics101ConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(ics101QueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101OrderQuery<TData> extends Ics101ReactQuery<OrderResponse, TData> {
  args: {
    orderId: string;
    poolId: string;
  };
}
export function useIcs101OrderQuery<TData = OrderResponse>({
  client,
  args,
  options
}: Ics101OrderQuery<TData>) {
  return useQuery<OrderResponse, Error, TData>(ics101QueryKeys.order(client?.contractAddress, args), () => client ? client.order({
    orderId: args.orderId,
    poolId: args.poolId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101OrderListQuery<TData> extends Ics101ReactQuery<OrderListResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useIcs101OrderListQuery<TData = OrderListResponse>({
  client,
  args,
  options
}: Ics101OrderListQuery<TData>) {
  return useQuery<OrderListResponse, Error, TData>(ics101QueryKeys.orderList(client?.contractAddress, args), () => client ? client.orderList({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Ics101SwapMutation {
  client: Ics101Client;
  msg: {
    poolId: string;
    recipient: string;
    sender: string;
    slippage: number;
    swapType: SwapMsgType;
    timeoutHeight: number;
    timeoutTimestamp: number;
    tokenIn: Coin;
    tokenOut: Coin;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useIcs101SwapMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Ics101SwapMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Ics101SwapMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.swap(msg, fee, memo, funds), options);
}
export interface Ics101MultiAssetWithdrawMutation {
  client: Ics101Client;
  msg: {
    counterpartyReceiver: string;
    poolId: string;
    poolToken: Coin;
    receiver: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useIcs101MultiAssetWithdrawMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Ics101MultiAssetWithdrawMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Ics101MultiAssetWithdrawMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.multiAssetWithdraw(msg, fee, memo, funds), options);
}
export interface Ics101TakeMultiAssetDepositMutation {
  client: Ics101Client;
  msg: {
    orderId: string;
    poolId: string;
    sender: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useIcs101TakeMultiAssetDepositMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Ics101TakeMultiAssetDepositMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Ics101TakeMultiAssetDepositMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.takeMultiAssetDeposit(msg, fee, memo, funds), options);
}
export interface Ics101CancelMultiAssetDepositMutation {
  client: Ics101Client;
  msg: {
    orderId: string;
    poolId: string;
    sender: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useIcs101CancelMultiAssetDepositMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Ics101CancelMultiAssetDepositMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Ics101CancelMultiAssetDepositMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.cancelMultiAssetDeposit(msg, fee, memo, funds), options);
}
export interface Ics101MakeMultiAssetDepositMutation {
  client: Ics101Client;
  msg: {
    chainId: string;
    deposits: DepositAsset[];
    poolId: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useIcs101MakeMultiAssetDepositMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Ics101MakeMultiAssetDepositMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Ics101MakeMultiAssetDepositMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.makeMultiAssetDeposit(msg, fee, memo, funds), options);
}
export interface Ics101SingleAssetDepositMutation {
  client: Ics101Client;
  msg: {
    poolId: string;
    sender: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
    token: Coin;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useIcs101SingleAssetDepositMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Ics101SingleAssetDepositMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Ics101SingleAssetDepositMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.singleAssetDeposit(msg, fee, memo, funds), options);
}
export interface Ics101CancelPoolMutation {
  client: Ics101Client;
  msg: {
    poolId: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useIcs101CancelPoolMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Ics101CancelPoolMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Ics101CancelPoolMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.cancelPool(msg, fee, memo, funds), options);
}
export interface Ics101TakePoolMutation {
  client: Ics101Client;
  msg: {
    counterCreator: string;
    creator: string;
    poolId: string;
    timeoutHeight: number;
    timeoutTimestamp: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useIcs101TakePoolMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Ics101TakePoolMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Ics101TakePoolMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.takePool(msg, fee, memo, funds), options);
}
export interface Ics101MakePoolMutation {
  client: Ics101Client;
  msg: {
    counterpartyChannel: string;
    counterpartyCreator: string;
    creator: string;
    destinationChainId: string;
    liquidity: PoolAsset[];
    sourceChainId: string;
    sourceChannel: string;
    sourcePort: string;
    swapFee: number;
    timeoutHeight: number;
    timeoutTimestamp: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useIcs101MakePoolMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Ics101MakePoolMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Ics101MakePoolMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.makePool(msg, fee, memo, funds), options);
}